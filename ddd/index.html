<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>Meaningful DDD</title>

		<link rel="stylesheet" href="dist/reset.css">
		<link rel="stylesheet" href="dist/reveal.css">
		<link rel="stylesheet" href="dist/theme/blood.css" id="theme">

		<!-- Theme used for syntax highlighted code -->
		<link rel="stylesheet" href="plugin/highlight/monokai.css" id="highlight-theme">
	</head>
	<body>
		<div class="reveal">
			<div class="slides">
			<!--0.intro-->
			<section>
				<section>
					<h1>DDD 领域驱动设计入门</h1>
					<h2 class="fragment">应对软件复杂性</p>
				</section>
				<section>
					<h2>Contents</h2>
					<ul>
						<li>DDD 是什么 ?</li>
						<li>为什么要学习 DDD ?</li>
						<li>如何实施 DDD ?</li>
						<li>More...</li>
					</ul>
				</section>
			</section>

			<!--1.ddd是什么-->
			<section>
				<!--1.1 引子-->
				<section>
					<h2>DDD 是什么?</h2>
					<h3 class="fragment">初识 DDD</h3>
					<p class="fragment">"DDD" <span class="fragment"> = </span> <span class="fragment">Domain Driven Design</span></p>
					<p class="fragment">"领域驱动设计"</p>
					<p class="fragment">一套指导软件设计与实施的<span class="ustrong">方法论</span></p>
				</section>
				<!--1.2 概念说明-->
				<section>
					<h3>关键术语</h3>
					<table style="font-size:0.7em">
						<tr><th>术语</th><th>意义</th><th>说明</th></tr>
						<tr>
							<td><span class="term">领域</span></td>
							<td>问题空间</td>
							<td>某一类业务问题, 比如"如何发布内容"</td>
						</tr>
						<tr>
							<td><span class="term">限界上下文</span></td>
							<td>解空间</td>
							<td>对应于某一个<span class="term">领域</span>的解决方案, 比如内容发布系统</td>
						</tr>
						<tr>
							<td><span class="term">领域模型</span></td>
							<td>对领域内的对象建模, 封装业务逻辑</td>
							<td>内容发布系统中的"评论"对象, 具有删除动作</td>
						</tr>
						<tr>
							<td><span class="term">实体对象</span></td>
							<td>领域模型的一种, 具有全局唯一性</td>
							<td>"发布系统"上下文中的"评论"对象是实体对象</td>
						</tr>
						<tr>
							<td><span class="term">值对象</span></td>
							<td>领域模型的一种, 生命周期短, 不唯一</td>
							<td>"发布系统"上下文中的"帖子"对象的内容文本是值对象</td>
						</tr>
					</table>
				</section>
				<!--1.3 举例说明-->
				<section>
					<h3>举例说明</h3>
					<div class="fragment">
						<p>对于"社区内容"问题(<span class="term">领域</span>):</p>
						<p>我们<span class="ustrong">定义</span>出"帖子上下文"(<span class="term">限界上下文</span>);</p>
						<p>在该上下文中, 我们有帖子这一</span>(<span class="term">实体</span>)对象;</p> 
						<p>该对象可能包含的属性有 "帖子标题", "帖子内容"</p>
						<p>这些属性都是<span class="term">值对象</span></p>
					</div>
					<aside class="notes">
						点到为止
					</aside>

				</section>
			</section>

			<!--2.为什么要学 ddd-->
			<section>
				<section>
					<h2>为什么要学习 DDD?</h2>
				</section>
				<section>
					<aside class="notes">
						TODO 每一条可以举个例子
						1. 业务定义不清晰: 张小龙想要做微信短视频, 短视频到底是什么? 我们需要人为定义出这个短视频系统的边界, 确定它能做什么不能做什么
						2. 业务用语歧义: 开会沟通, 参会的有运营, 产品, 研发, 用户等, 大家说到"漫画", 到底是指"漫画作品"这一概念? 还是我们平台上的漫画? 还是指漫画章节?
						3. 业务逻辑丢失: 程序员的实现不会和产品文档完全一致(或者是产品口头需求没有记录), 总之, 在迭代的长河中, 我们最终总会有那么几次只能依赖读代码来推理业务逻辑
						4. 业务扩展困难: 好吧, 这应该是程序员的锅, 软件设计上做的不够灵活多变
					</aside>
					<h3>产研实践的缺陷</h3>
					<ul class="fragment">
						<li class="fragment">业务定义不清晰</li>
						<li class="fragment">业务用语有歧义</li>
						<li class="fragment">业务逻辑丢失</li>
						<li class="fragment">业务扩展困难</li>
					</ul>
				</section>
				<section>
					<h3>DDD 的优点</h3>
					<ul class="fragment">						
						<li>以<span class="ustrong">业务</span>为核心, 围绕业务开展活动</li>
						<li>建立全员一致的<span class="ustrong">业务</span>理解</li>
						<li>更好的团队投入与参与(产品, 运营, 开发者, etc)</li>
						<li>更好的发掘/梳理<span class="ustrong">业务价值</span>, 聚焦高价值的业务</li>
						<li>领域模型即<span class="ustrong">业务</span>逻辑</li>
						<li>代码更加易于维护,扩展;(可能)更高的代码质量</li>
					</ul>
					<aside class="notes">
						model 中的业务逻辑, service 中没有业务逻辑!
					</aside>
				</section>
				
			</section>

			<!--3. 如何实施 DDD-->
			<section>
				<section>
					<h2>如何实施 DDD?</h2>
					<ol class="fragment">
						<li>梳理业务逻辑</li>
						<li>输出共识</li>
						<li>为领域建模</li>
						<li>完整架构</li>
					</ol>
				</section>
				<section>
					<h3> 1. 梳理业务逻辑</h3>
					
					<p class="fragment">这是 ddd 开始阶段要做的第一件事</p>
					<p class="fragment">我们可以使用名为<span class="ustrong">"EVENT STORMING"</span>的技术来帮助我们梳理业务</p>
					<div class="fragment" style="font-size:0.5em;color:grey;">
						<p style="margin-bottom:3px"><b>EVENT STORMING 步骤参考</b></p>
						<ol>
							<li>确定要讨论的业务</li>
							<li>召集相关方聚在有白板的会议室中</li>
							<li>通过brainstorm 提出业务的<span class="ustrong">事件</span>, 贴上白板</li>
							<li>如果事件 A 触发了事件 B, <span class="ustrong">连接</span>它们</li>
							<li>重复3-4步</li>
						</ol>
						<p>最后我们就得到了业务的全部流转逻辑</p>
					</div>
					
					<aside class="notes">				
						<p>1. event storming 是对业务逻辑的梳理, 对于"创建合集"操作来说, 就是该操作完整的业务流程以及各种逻辑分支</p>
						<p>2. event storming 需要我们集合<b>领域专家</b>采纳听取他们的意见, 厘清业务逻辑中的要点</p>
					</aside>
				</section>
				<section id="output">
					<h3>2. 输出共识</h3>
					<div class="fragment">
						<p>
						共识即<span class="term">领域通用语言</span>
						</p>
						<p>通用语言包含:</p>
						<ul>
							<li>领域 和 限界上下文</li>
							<li>用语词典</li>
							<li>业务流程图</li>
						</ul>
					</div>
				</section>
				<section id="context">
					<div>
						<h4>领域 & 限界上下文</h4>
						<p class="fragment"><span class="term">领域</span>= 问题空间</p>
						<p class="fragment"><span class="term">限界上下文</span>= 解空间 <span class="fragment">需要<span class="ustrong">由团队人为划定边界</span></span> </p>
						
						<p class="fragment">例如, 对于帖子合集功能</p>
					
						<p class="fragment">"领域" = 帖子合集的所有功能点</p>
						<p class="fragment">"限界上下文" = "<span class="term">合集上下文</span>", 包含
							<ol class="fragment">
								<li>对合集操作的实际工作流程(交互与代码实现)</li>
								<li>对帖子与合集关系的操作的实际工作流程</li>
							</ol>
						</p>
					</div>
					<!--<a class="fragment" style="color:grey" href="#/output">back</a>-->
					<aside class="notes">
						
					</aside>
				</section>
				<section id="dict">
					<h4>用语词典</h4>
					<p style="font-size:0.7em">"合集"领域的词典</p>
					<div>
						<table>
							<tr><th>用语</th><th>说明</th></tr>
							<tr><td>合集</td><td>用于组织用户发布的帖子的一种承载物</td></tr>
							<tr><td>用户</td><td>一个用户即代表一个社区账号</td></tr>
							<tr><td>帖子</td><td>社区单个用户单次生产内容的主要形式, 可以包含文本,图片,视频多种内容</td></tr>
							<tr><td>...</td><td>...</td></tr>
						</table>
					</div>
					<!--<a class="fragment" style="color:grey" href="#/output">back</a>-->
					<aside class="notes">
						用语词典的全称是"领域 XXX 的用语词典", 也就是说, 一个用语词典中的任何词汇只在其对应的领域以及上下文中表达一个清晰无歧义的概念;
					</aside>
				</section>
				<section id="flow">
					<h4>流程图</h4>
					<div class="notes">
						<img src="./img/compilation.png"/>
					</div>
					<!--<a class="fragment" style="color:grey" href="#/output">back</a>-->
					<aside class="notes">
						在合集开发中, 用流程图和产品方进行了确认
					</aside>
				</section>
				<section>
					<h3>conclusion 1</h3>
					<p>DDD 以<span class="ustrong">业务</span>为中心, 业务即Domain(<span class="term">领域</span>)</p>
					<p><span class="ustrong">"理解领域"</span>是实施 DDD 的第一步</p>
					<p>达成并输出<span class="ustrong">共识</span>十分重要</p>
					<aside class="notes">

					</aside>
				</section>
				<section>
					<h3> 3. 为领域建模</h3>
					<p class="ustrong">将业务逻辑封装在领域模型中!</p>
					<aside class="notes">
						TODO 对比 service 和 Domain Object
					</aside>
					<div>
						<pre><code>
							class SomeService
						</code></pre>
					</div>
				</section>
				<section>
					<h5 class="fragment ustrong">"值对象"</h5>
					<ul class="fragment">
						<li>不唯一</li>
						<li>生命周期短</li>
						<li>不可变</li>
					</ul>
					<aside class="notes">
						0. 首先简要介绍一下 kotlin 语法
							1. val = final
							2. var = mutable prop
							3. ? = @Nullable
						1. 请试着说出这段代码的业务逻辑
						2. "值对象"的概念介绍: 在业务中不具备唯一性的对象, 比如通常意义上的姓名, 用户所在城市, 一段用户输入的文案等; 特点包括
							1. 生命周期短 - 需要结合实体对象来说明, 暂时认为, 只有值对象是无法存在或者具有意义的
							2. 不可变
					</aside>
				</section>
				<section>
					<h5>试看一例</h5>
					<aside class="notes">
						0. 首先简要介绍一下 kotlin 语法
							1. val = final
							2. var = mutable prop
							3. ? = @Nullable
						1. 请试着说出这段代码的业务逻辑
						2. "值对象"的概念介绍: 在业务中不具备唯一性的对象, 比如通常意义上的姓名, 用户所在城市, 一段用户输入的文案等; 特点包括
							1. 生命周期短 - 需要结合实体对象来说明, 暂时认为, 只有值对象是无法存在或者具有意义的
							2. 不可变
					</aside>
					<div>

<pre class="fragment"><code class="kotlin" data-trim data-noescape data-line-numbers>
data class Title(
        val title: String
) : SimpleValueObject&lt;Title> {
    init {
        if (title.isBlank()) {
            throw BadRequestException()
        }
        if (title.length > 30) {
            throw BadRequestException()
        }
    }
}
</code></pre>
<pre class="fragment"><code class="kotlin" data-trim data-noescape data-line-numbers>
data class CompilationID(
        val id: Long
) : SimpleValueObject&lt;CompilationID> {
    init {
        if(id &lt;= 0) { 
            throw BadRequestException()
        }
    }
}
</code></pre>

					</div>
				</section>

				<section>
					<h5 class="fragment ustrong">"实体对象"</h5>
					<ul class="fragment">
						<li>唯一性/身份</li>
						<li>生命周期长</li>
						<li>可变</li>
					</ul>
					<aside class="notes">
						<pre>
						0. 首先简要介绍一下 kotlin 语法
							1. val = final
							2. var = mutable prop
							3. ? = @Nullable
						1. 请观众说明该段代码的业务含义
							1. 成员对象的可变性(val, var)
							2. 可变属性的变更=替换操作 , 当我们修改某个属性时, 直接将该属性对象替换为一个新的值对象即可
						2. "实体"解释
							1. 唯一性: Compilation 由 compilationId 成员属性全局唯一地标识了它的身份
							2. 生命周期长, 一个 Compilation 对象会通过"资源库"存活在持久化层, 具有最长的生命周期
							3. Compilation 对象是可变的, 体现在其可变成员属性上

						</pre>
					</aside>
				</section>
				<section>
					<h5>试看一例</h5>
					<aside class="notes">
						0. 首先简要介绍一下 kotlin 语法
							1. val = final
							2. var = mutable prop
							3. ? = @Nullable
						1. 请观众说明该段代码的业务含义
							1. 成员对象的可变性(val, var)
							2. 可变属性的变更=替换操作 , 当我们修改某个属性时, 直接将该属性对象替换为一个新的值对象即可
						2. "实体"解释
							1. 唯一性: Compilation 由 compilationId成员属性全局唯一地标识了它的身份
							2. 生命周期长, 一个 Compilation 对象会存活在持久化层, 具有最长的生命周期
							3. Compilation 对象是可变的, 体现在其可变成员属性上
					</aside>
					<div class="fragment">
						<pre><code class="kotlin" data-trim data-noescape data-line-numbers>
						class Compilation private constructor(
								val compilationID: CompilationID,
								val author: Author,
								private var title: Title,
								private var description: Description?,
								private var cover: String?,
								private var status: CompilationStatus,
								private var createTime: Long
						) : SmartEntity&lt;Compilation>() {
						
							fun title() = title
						
							fun updateTitle(newTitle: Title) {
								title = newTitle
								refreshTouchTime()
							}
						
							/* 
							......... some other detail
							*/
						}
						</code></pre>
					</div>
				</section>

				<section>
					<h3>创建纯洁的领域对象</h3>
					<h5>忘记 DB, 领域优先</h5>
					<aside class="notes">
						例子中是一个典型的 POJO, 或者说 DTO (data transfer object), 而且拥有与 schema 一一对应的字段
					</aside>
					<div class="fragment fade-out">
						<img src="./img/first_line.jpeg" />
					</div>
					<table class="fragment fade-in">
						<th>
							<td>NO</td><td>YES</td>
						</th>
						<tr>
							<td>
								<pre><code class="kotlin" data-noescape data-trim">
									class BadDomain {
										private var id:Int =0;
										private var name:String="";
										private var createTime:Long=0L;
										private var updateTime:Long=0L;
										private var status:Byte=0L
										/*...
												setters and getters
										...*/
									}
								</code></pre>
							</td>

							<td>
								<pre><code class="kotlin data-noescape data-trim">
									class GoodDomain {
										private var name:String
										fun setName(newName:String){
											if (newName.length > 30) throw BadRequestException("名称长度过长")
										}
									}
								</code></pre>
							</td>
						</tr>
					</table>
				</section>
				<section>
					<h4>创建纯洁的领域对象</h4>
					<h5>对象对应于<span class="term">上下文</span>中的一个清晰概念</h5>
					<aside class="notes">
						对于发布系统上下文
					</aside>
					<table class="fragment fade-in">
						<th>
							<td>NO</td><td>YES</td>
						</th>
						<tr>
							<td>
								<pre><code class="kotlin" data-noescape data-trim">
									class User {
										private var id: Int =0
										private var name: String=""
										private var gender: Gender=FEMALE
										private var phone: String?=null
										private var mail: String?= null
										private var posts: Int = 0
										private var lastLoginTime: Long=0L	
									}
								</code></pre>
							</td>

							<td>
								<pre><code class="kotlin data-noescape data-trim">
									class Author {
										private var id:Int = 0
										private var gender:Gender=FEMALE
										private var posts:Int=0
										init {
											if(id <= 0) throw BadRequestException("用户 id 无效")
										}
									}
									/*.......*/
									interface addPost(author:Author, post:Post)
								</code></pre>
							</td>
						</tr>
					</table>
				</section>

				<section>
					<h4>创建纯洁的领域对象</h4>
					<h5>对象只有单一的<span class="ustrong">职责</span>(SRP)</h5>
					<table class="fragment fade-in">
						<th>
							<td>NO</td><td>YES</td>
						</th>
						<tr>
							<td>
								<pre><code class="kotlin" data-noescape data-trim">
									class UserAccount {
										private var id: Int =0
										private var status:Status=OK
										private var followings: Set&lt;UserAccount>
										
										fun addFollowing(other:UserAccount) {
											followings.add(other)
										}

										fun ban(){
											status = BANNED
										}
									}
								</code></pre>
							</td>

							<td>
								<pre><code class="kotlin data-noescape data-trim">
									class UserAccount {
										private val id: Int =0
										private var status:Status=OK
										fun ban(){
											status = BANNED
										}
									}
									class SocialNetworkUser {
										private val id: Int = 0
										private var followings: Set&lt;SocialNetworkUser>
										fun follow(other:SocialNetworkUser){ /*...*/ }
										fun unfollow(toUnfollow:SocialNetworkUser) { /*...*/ }
									}
								</code></pre>
							</td>
						</tr>
					</table>
				</section>
				<section>
					<h4>创建纯洁的领域对象</h4>
					<h5>对象不知道其职责以外的任何知识</h5>
					<table class="fragment fade-in">
						<th>
							<td>NO</td><td>YES</td>
						</th>
						<tr>
							<td>
								<pre><code class="kotlin" data-noescape data-trim">
									class UserAccount {
										private val id: Int =0
										private var status: Status=OK
										private var banReason: String?=null
										fun ban(reason: OutSideReason){
											status = BANNED
											banReason = when (reason) {
												BAD_BEHAVIOR -> DomainEnum.BAD_BEHAVIOR.str
												ADMIN_BAN -> DomainEnum.ADMIN_BAN.str
												else->null
											}
										}
									}
								</code></pre>
							</td>

							<td>
								<pre><code class="kotlin data-noescape data-trim">
									class UserAccount {
										private val id: Int =0
										private var status: Status=OK
										private var banReason: String?=null
										fun ban(reason: DomainEnum){
											status = BANNED
											banReason = reason.str
										}
									}
								</code></pre>
							</td>
						</tr>
					</table>
				</section>
				<section>
					<h3>conclusion 2 </h3>
					<p>将所有业务逻辑封装到领域模型中</p>
					<p>创建纯洁的领域对象</p>
					<aside class="notes" data-markdown data-template>
						TODO 举例子? 或者换掉后面的两个例子
					</aside>
				</section>

				<section>
					<h3>架构概述</h3>
					<p>原则</p>
					<ul>
						<li>将 IO 推到系统边界</li>
						<li>避免领域污染</li>
						<li>应用 CQRS 模式</li>
					</ul>
					
					<aside class="notes">
						TODO 考虑介绍六边形架构
					</aside>
				</section>
				<section>
					<h3>架构概述</h3>
					<h4>示例</h4>
					<aside class="notes">
						<pre>
							1. IO推到系统边界
								1. 保持了领域对象的纯洁
								2. 解耦了业务逻辑和实现,利于重构和变更
							2. 避免领域污染
								1. 保持领域对象的纯洁
								2. 领域完整且自治
							3. CQRS
								1. 写模型易于抽象成领域模型, 读模型则不是
								2. 分离后每个服务专注于单独的一个职责(读/写)
								3. 读写的同步问题
						</pre>
					</aside>
					<p><img src="./img/architecture.png"/></p>
				</section>
				<section>
					<h3>conclusion 3</h3>
					<p>架构/基础设施应该与<span class="term">领域模型</span>解耦</p>
				</section>
			</section>

			<!--4 总结-->
			<section>
				<section>

				<h3>To sum it up</h3>
				<aside class="notes">
					TODO 回顾观点
				</aside>
				</section>
				<section>
				<div class="fragment">
					<h4>DDD 是什么?</h4>
					<p>以业务为中心的软件设计和实施方法论</p>
				</div>
				</section>

				<section>
				<div class="fragment">
					<h4>为什么要学习 DDD ?</h4>
					<ul>
						<li>产研实践损害了业务完整性</li>
						<li>DDD 框架围绕业务开展活动</li>
					</ul>
				</div>
				</section>

				<section>
				<div class="fragment">
					<h4>如何实施 DDD?</h4>
					<ol>
						<li>梳理业务逻辑</li>
						<li>建立并输出业务共识</li>
						<li>设计领域模型</li>
						<li>实现架构中的组件</li>
					</ol>
				</div>
				</section>
			</section>


			<section>
				<section><h2>More</h2></section>
				<section><h3>Q & A</h3></section>
				<section>
					<h3>References</h3>
					<h4>if you're still interested</h4>
					<p>欢迎阅读 <a href="https://wiki.quickcan.com/pages/viewpage.action?pageId=175243524#DDD(领域驱动设计)实践-review_log">DDD 实战记录</a></p>
					<p>以及参考<a href="https://git.quickcan.com/social/social-feed-service/-/tree/master/src/main/kotlin/com/kk/social/experimental/ddd/compilation" target="_blank">社区合集实现</a>
					</p>
				</section>
			</section>
			</div>
		</div>

		<script src="dist/reveal.js"></script>
		<script src="plugin/notes/notes.js"></script>
		<script src="plugin/markdown/markdown.js"></script>
		<script src="plugin/highlight/highlight.js"></script>
		<script>
			// More info about initialization & config:
			// - https://revealjs.com/initialization/
			// - https://revealjs.com/config/
			Reveal.initialize({
				hash: true,

				// Learn about plugins: https://revealjs.com/plugins/
				plugins: [ RevealMarkdown, RevealHighlight, RevealNotes ]
			});

		</script>
		<style type="text/css">
			.reveal section pre code {
				font-size: 0.7em !important;
			}
			.reveal section .ustrong {
				color: #CC3300;
				font-style:	bold !important;
				font-weight: 500px !important;
			}
			.reveal section.dialogue p {
				font-size: 0.6em !important;
				text-align: left;
				padding-left: 2em ;
			}
			.reveal section .term {
				font-style: normal !important;
				color: #0099ff	!important;
				border-bottom: 1px solid;
			}
		</style>
	</body>
</html>
