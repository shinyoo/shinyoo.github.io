<!doctype html>
<html>

<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

	<title>Meaningful DDD</title>

	<link rel="stylesheet" href="dist/reset.css">
	<link rel="stylesheet" href="dist/reveal.css">
	<link rel="stylesheet" href="dist/theme/blood.css" id="theme">

	<!-- Theme used for syntax highlighted code -->
	<link rel="stylesheet" href="plugin/highlight/monokai.css" id="highlight-theme">
</head>

<body>
	<div class="reveal">
		<div class="slides">
			<!--0.intro-->
			<!-- <div INTRO> -->
			<section WHO>
				<h1>我是谁</h1>
				TODO
			</section>
			<section COVER>
				<h1>领域驱动设计入门</h1>
				<h2 class="fragment">应对软件复杂性</p>
			</section>
			<section ROADMAP>
				<h2>分享路线图</h2>
				<ul>
					<li>为什么做这个分享?</li>
					<li>关于领域驱动设计</li>
					<li>DDD 案例研究</li>
					<li>结论与 Q&A</li>
				</ul>
			</section>
			<!-- </div> -->


			<!--为什么分享 ddd-->
			<!-- <section WHY-DDD> -->
			<section WHY-TALK data-markdown>
				## 为什么做这个分享
				* 应对编码中的痛点
				* 应对产研实践的痛点
			</section>
			<section WHY-TALK2 data-notes="					
个人一直对'编码'或者更具体地说'编写优雅的代码'这件事有执念, 也经常被这些问题困扰:
1. 如何写出更简洁, 易读的业务代码?
	比如, 按照产品文档实现的需求, 2 年前的我, 写出的代码可能饶一个大圈子完成了需求功能;
2. 如何将业务逻辑和技术细节分离?
    技术细节的变动不应该导致我们业务逻辑变化(比如存储结构变化/外部服务协议变化)
3. 如何让代码更容易变更
	比如,对业务逻辑做出恰当的抽象..
4. 如何让代码更易于测试?
    易于单元测试, 尽可能提升代码交付质量

因此最近开发的新功能, 使用了 DDD 的方式完成了初次完整的尝试;
在这个过程中, 对于 DDD 抽象、模糊的概念有了一些感性的认识，也有了一些有益的收获, 今天想要分享给大家
优雅的代码实现
">
				<aside data-markdown class="notes">
					个人一直对'编码'或者更具体地说'编写优雅的代码'这件事有执念, 也经常被这些问题困扰:

					1. 可读性差
					1. 代码中大量的条件分支, 理解困难
					2. 变量命名不清楚
					2. 面条代码/不合理的方法封装?
					1. 仅因为代码长度分割方法
					2. 不断地增加方法入参去区分非主干逻辑(TODO 举例子)
					4. 代码难以变更
					1. 不同业务的代码混合在一起, 牵一发动全身(TODO 举例子)
					5. 代码难以测试
					1. 难以单元测试, 过多的外部依赖需要 mock

					因此最近开发的新功能, 使用了 DDD 的方式完成了初次完整的尝试;
					在这个过程中, 对于 DDD 抽象、模糊的概念有了一些感性的认识，也有了一些有益的收获, 今天想要分享给大家
					优雅的代码实现
				</aside>
				<h2>为什么做这个分享?</h2>
				<h3>应对编码中的痛点</h3>
				<ul>
					<li data-fragment-index="1">代码可读性差</li>
					<li data-fragment-index="3">面条代码/不合理的方法封装</li>
					<li data-fragment-index="7">代码变更困难, 修改容易出错</li>
					<li data-fragment-index="9">代码难以测试</li>
				</ul>
			</section>
			<section WHY-TALK1 data-markdown data-notes="
ddd 思想和工具有助于我们解决这些痛点
1. 为什么需要研发清晰地理解需求细节?
	1. 准确地实现产品意图
	2. 准时交付: bad case 开始研发后会发现很多细节坑, 不断地引出新的问题, 可能导致项目进度滞后
	2. 技术服务于业务价值， 脱离业务的技术没有价值
	3. 业务在我司是非常重要的: 垂直领域, 当前体量+发展阶段, 需要我们懂业务
	4. 理解业务也是程序员的关键能力之一
1. 为什么产品需要知道实现的关键细节?
	1. 懂得解决方案, 可以更完整地理解业务
	2. 能够更加合理地评估研发成本
	3. 利于和研发顺利地沟通
1. 长期迭代后, 业务需求分散, 不完整		
   分散在多次迭代、多种规格和为之的增量式的产品文档中
需求评审时产品 owner 使用非标准化的方式去宣讲需求, 研发只能作为听众, 尝试理解需求, 被动接受信息

TODO
 1. meme img
 2. meme img
 3. meme img
				">
				## 为什么做这个分享?
				### 应对产研实践的痛点
				* 研发不能清晰地理解需求细节
				* 产品不知道技术实现的关键细节
				* 长期迭代后, 业务知识分散
			</section>

			<!-- 关于 DDD -->
			<section ABOUT-DDD data-markdown>
				## 关于领域驱动设计
				1. 背景介绍
				1. 核心原则
				1. 关键术语
			</section>
			<section ABOUT-DDD0>
				<h2>关于领域驱动设计</h2>
				<h3>1. 背景介绍</h3>
				<aside class="notes" data-markdown>
					1. 他不是一种设计模式
					2. 他是一种高层次/宏观的软件设计和实施方法
					3. 引用 MF: 他的核心是要创建"通用语言", 从而将"领域"术语嵌入到我们构建的软件系统中
				</aside>
				<p>DDD = "Domain Driven Design" = "领域驱动设计"</p>
				<p>最早由 Eric Evans 2003年的"Domain Driven Design"一书中提出的一种软件开发方法</p>
				<p>Martin Fowler On DDD:
					<q>the heart of this was the idea that to develop software for a complex domain, we need to build
						Ubiquitous Language that embeds domain terminology into the software systems that we build</q>
				</p>
			</section>

			<section ABOUT-DDD1>
				<h2>关于领域驱动设计</h2>
				<h3>2. 核心原则</h3>
				<h4>以业务为<span class="ustrong">核心</span>开展活动</h4>
				<ul>
					<li>团队成员应该优先关注业务</li>
					<li>全员需要建立一致的业务理解</li>
				</ul>
				<aside data-markdown class="notes">
					重要的事说三遍
					什么叫"以业务为核心开展活动"? 业务的地位是最高的
					* 前提: 全员需要建立一致的业务理解
					业务 = 产品需求 + 关键实现细节(软件工作流程)
					* 所有团队成员应该优先关注业务, 理解业务
					1. 研发: 保证业务实现的完整
					2. 产品: 理解实现的关键细节

					为什么有助于解决上述痛点?
					* 用更直接的形式保证团队参与到"业务知识"的梳理中, 而非产品单向的宣讲, 提升团队成员的参与感与责任感
					* 通过共同参与、达成共识，
					1. 帮助定义清晰的业务边界（can and cannots)

				</aside>
			</section>


			<!--1.2 概念说明-->
			<section ABOUT-DDD-TERM>
				<h2>关于领域驱动设计</h2>
				<h3>3. 关键术语</h3>
				<aside class="notes">
					TODO 使用一张图代替该表格的第三列说明
				</aside>

				<table style="font-size:1em">
					<tr>
						<th>术语</th>
						<th>意义</th>
						<!-- <th>说明</th> -->
					</tr>
					<tr>
						<td><span class="term">领域</span></td>
						<td>代表了需要解决的业务问题</td>
						<!-- <td>某一类业务问题, 比如"如何让用户组织自己的已发布内容"</td> -->
					</tr>
					<tr>
						<td><span class="term">限界上下文</span></td>
						<td>对应于领域, 代表了解决业务问题的方案</td>
						<!-- <td>对应于某一个<span class="term">领域</span>的解决方案, 比如内容组织系统</td> -->
					</tr>
					<tr>
						<td><span class="term">领域模型</span></td>
						<td>将业务逻辑抽象成模型; <br />包含<span class="term">实体对象</span>和<span class="term">值对象</span>两个重要分类</td>
						<!-- <td>内容发布系统中的"评论"对象, 具有删除动作</td> -->
					</tr>
				</table>
			</section>
			<section>
				<!-- <h2>关于领域驱动设计</h2> -->
				<h3>3. 关键术语</h3>
				<img class="r-strech" src="./img/domain-bc.jpg" />
				<p>图示</p>
			</section>

			<!--DDD 案例研究-->
			<!-- <section HOWTO> -->
			<section HOWTO data-markdown>
				## DDD 案例研究
				1. 案例背景介绍
				1. 工序之一: 梳理业务逻辑
				1. 工序之二: 创建领域模型
				1. 工序之三: 围绕模型构建服务
			</section>
			<section HOWTO-bg data-markdown>
				TODO?
				产品视角
				开发视角

				## DDD 案例研究
				### 1. 案例背景介绍
				"社区合集需求"

				> 由于快看的生产者发布作品可能是连续性的，或者是需要归类整理的，所以需要使用合集形式对内容进行整理
			</section>
			<section HOWTO-pre>
				<h2>DDD 案例研究</h2>
				<h3>工序之一: 梳理业务逻辑</h3>
				<h4>梳理<span class="ustrong">业务逻辑</span>, 输出业务<span class="ustrong">共识</span></h4>
			</section>
			<section HOWTO-pre>
				<h2>DDD 案例研究</h2>
				<h3>工序之一: 梳理业务逻辑</h3>
				<img style="height:400px" src='./img/ddd-agree.svg' />
				<aside class="notes">
					<div style="font-size:0.5em;color:grey;">
						<p style="margin-bottom:3px"><b>EVENT STORMING 步骤参考</b></p>
						<ol>
							<li>确定要讨论的业务</li>
							<li>召集相关方聚在有白板的会议室中</li>
							<li>通过brainstorm 提出业务的<span class="ustrong">事件</span>, 贴上白板</li>
							<li>如果事件 A 触发了事件 B, <span class="ustrong">连接</span>它们</li>
							<li>重复3-4步</li>
						</ol>
						<p>最后我们就得到了业务的全部流转逻辑</p>
					</div>
				</aside>
			</section>
			<section HOWTO-biz>
				<h2>DDD 案例研究</h2>
				<h3>工序之一: 梳理业务逻辑</h3>
				<h4>输出之一: 领域和上下文</h4>
				<div>
					<p class="fragment"><span class="term">领域</span> = 如何让用户组织自己已发表的内容?</p>
					<p class="fragment"><span class="term">限界上下文</span> = <span class="ustrong">合集上下文</span>,
						使用"合集"功能解决用户组织内容的问题; 该上下文包含合集生产与消费方案:
					<ul class="fragment">
						<li>用户界面</li>
						<li>后端系统</li>
					</ul>
					</p>
				</div>
				<aside class="notes">
					1. 领域可大可小, 也可以包含子域
					2. 注意到一个上下文只解决一个领域的问题
					3. !! 注意, 虽然 ddd 是用于设计软件的, 但"软件"系统却只是"上下文"的一部分
				</aside>
			</section>
			<section HOWTO-biz>
				<!-- <h3>工序之一: 梳理业务逻辑</h3> -->
				<h4>输出之一: 领域和上下文</h4>
				<img class="r-strech" src="./img/domain-bc.jpg" />
			</section>
			<section HOWTO-biz id="dict">
				<h2>DDD 案例研究</h2>
				<h3>工序之一: 梳理业务逻辑</h3>
				<h4>输出之二: "合集"上下文的用语词典</h4>
				<div style="font-size:1em">
					<table>
						<tr>
							<th>用语</th>
							<th>说明</th>
						</tr>
						<tr>
							<td>合集</td>
							<td>用于组织用户发布的帖子的一种承载物</td>
						</tr>
						<tr>
							<td>用户</td>
							<td>一个用户即代表一个具备合集权限的社区用户</td>
						</tr>
						<tr>
							<td>帖子</td>
							<td>社区单个用户单次生产内容的主要形式;<br />可以包含文本,图片,视频多种内容</td>
						</tr>
						<tr>
							<td>...</td>
							<td>...</td>
						</tr>
					</table>
				</div>
				<aside class="notes">
					用语词典的全称是" XXX上下文 的用语词典", 也就是说, 一个用语词典中的任何词汇只在其对应的上下文中表达一个清晰无歧义的业务概念;
				</aside>
			</section>

			<section HOWTO-biz id="flow">
				<h2>DDD 案例研究</h2>
				<h3>工序之一: 梳理业务逻辑</h3>
				<h4>输出之三: "合集"上下文的流程图</h4>
				<img style="margin-top:0; height: 430px" src="./img/compilation.svg" />
				<aside class="notes" data-markdown>
					1. 在合集开发中, 用流程图和产品方进行了确认
					2. 注意流程中包含了必要的技术细节
					cue: 是否有问题?
				</aside>
			</section>


			<!-- TODO 是否需要放出该页 PPT? -->
			<section HOWTO-biz>
				<h2>DDD 案例研究</h2>
				<h3>小结之一</h3>
				<ul>
					<li><span class="ustrong">"理解领域(业务)"</span>是实施 DDD 的第一步</li>
					<li>"业务"包含实际的解决方案, <u>包含必要的技术细节</u></li>
					<li>达成并输出<span class="ustrong">共识</span>十分重要</li>
				</ul>
			</section>

			<section HOWTO-arch>
				<h2>DDD 案例研究</h2>
				<h3>架构一览</h3>
				<img style="height:500px" src='./img/arch-summary.jpg' />
			</section>
			<section HOWTO-arch-term data-markdown data-notes="
1. 说明组件的依赖关系
1. 领域对象/服务/事件不知道其他任何组件的存在
1. 应用服务调度基础设施
1. 说明领域的封闭特性			
						">
				<!--## DDD 案例研究-->
				### 架构一览
				|组件|说明|
				|---|---|
				|应用程序|接口, 操作领域对象的唯一入口|
				|基础设施|持久化、IO 操作在这一层|
				|领域对象|业务知识，业务逻辑的抽象|
				|领域服务|不能够抽象成对象的业务逻辑|
				|领域事件|领域内有意义的事件|
			</section>
			<section HOWTO-arch-dir>
				<h2>DDD 案例研究</h2>
				<h3>代码目录一瞥</h3>
				<div class="two-in-row">
					<img src='./img/source_structure.png' />
					
					<img src='./img/source_structure_2.png' />
				</div>
			</section>

			<section HOWTO-model>
	
			</section>

			<section HOWTO-model data-markdown data-notes="
忘记 DB, 避免持久化对领域对象的负面影响						
			">
				## DDD 案例研究
				### 工序之二: 创建领域模型
				#### 将业务逻辑映射到代码上!
				1. detour: 共识->过程式->领域对象
				1. straight-forward: 共识->领域对象
			</section>

			<section HOWTO-model data-markdown>
				## DDD 案例研究
				### 工序之二: 创建领域模型
				#### 将业务逻辑映射到代码上!
				##### detour: 过程式->领域对象
				```kotlin
				TODO
				```
			</section>
			<section HOWTO-model data-markdown>
				## DDD 案例研究
				### 工序之二: 创建领域模型
				#### 将业务逻辑映射到代码上!
				##### straight-forward: 领域知识->领域对象
				原则
				1. 创建边界清晰的对象
				1. 创建富有行为的对象
				1. 创建单一职责的对象
				```kotlin
				TODO
				```
			</section>


			<section HOWTO-model>
				<h2>DDD 案例研究</h2>
				<h3>工序之二: 创建领域模型</h3>
				<p class="ustrong">i.e. 将业务逻辑封装在领域模型中!</p>
				<aside class="notes">
					对比 service 和 Domain Object
				</aside>
				<table>
					<tr>
						<th>NO</th>
						<th>YES</th>
					</tr>
					<tr>
						<td><img src="./img/pasta.jpg"></td>
						<td><img src="./img/domained.jpg"></td>
					</tr>
				</table>
			</section>
			<section>
				<h2>DDD 案例研究</h2>
				<h3>工序之二: 创建领域模型</h3>
				<h4 class="ustrong">"值对象"</h4>
				<ul class="fragment">
					<li>不唯一</li>
					<li>生命周期短</li>
					<li>不可变</li>
				</ul>
				<aside class="notes">
					0. 首先简要介绍一下 kotlin 语法
					1. val = final
					2. var = mutable prop
					3. ? = @Nullable
					1. 请试着说出这段代码的业务逻辑
					2. "值对象"的概念介绍: 在业务中不具备唯一性的对象, 比如通常意义上的姓名, 用户所在城市, 一段用户输入的文案等; 特点包括
					1. 生命周期短 - 需要结合实体对象来说明, 暂时认为, 只有值对象是无法存在或者具有意义的
					2. 不可变
				</aside>
			</section>
			<section>
				<h4>试看一例</h4>
				<aside class="notes">
					0. 首先简要介绍一下 kotlin 语法
					1. val = final
					2. var = mutable prop
					3. ? = @Nullable
					1. 请试着说出这段代码的业务逻辑
					2. "值对象"的概念介绍: 在业务中不具备唯一性的对象, 比如通常意义上的姓名, 用户所在城市, 一段用户输入的文案等; 特点包括
					1. 生命周期短 - 需要结合实体对象来说明, 暂时认为, 只有值对象是无法存在或者具有意义的
					2. 不可变
				</aside>
				<div>

					<pre class="fragment"><code class="kotlin" data-trim data-noescape data-line-numbers>
data class Title(
        val title: String
) : SimpleValueObject&lt;Title> {
    init {
        if (title.isBlank()) {
            throw BadRequestException()
        }
        if (title.length > 30) {
            throw BadRequestException()
        }
    }
}
</code></pre>
					<pre class="fragment"><code class="kotlin" data-trim data-noescape data-line-numbers>
data class CompilationID(
        val id: Long
) : SimpleValueObject&lt;CompilationID> {
    init {
        if(id &lt;= 0) { 
            throw BadRequestException()
        }
    }
}
</code></pre>

				</div>
			</section>

			<section>
				<h4 class="ustrong">"实体对象"</h4>
				<ul class="fragment">
					<li>唯一性/身份</li>
					<li>生命周期长</li>
					<li>可变</li>
				</ul>
				<aside class="notes">
					<pre>
						0. 首先简要介绍一下 kotlin 语法
							1. val = final
							2. var = mutable prop
							3. ? = @Nullable
						1. 请观众说明该段代码的业务含义
							1. 成员对象的可变性(val, var)
							2. 可变属性的变更=替换操作 , 当我们修改某个属性时, 直接将该属性对象替换为一个新的值对象即可
						2. "实体"解释
							1. 唯一性: Compilation 由 compilationId 成员属性全局唯一地标识了它的身份
							2. 生命周期长, 一个 Compilation 对象会通过"资源库"存活在持久化层, 具有最长的生命周期
							3. Compilation 对象是可变的, 体现在其可变成员属性上

						</pre>
				</aside>
			</section>
			<section>
				<h4>试看一例</h4>
				<aside class="notes">
					0. 首先简要介绍一下 kotlin 语法
					1. val = final
					2. var = mutable prop
					3. ? = @Nullable
					1. 请观众说明该段代码的业务含义
					1. 成员对象的可变性(val, var)
					2. 可变属性的变更=替换操作 , 当我们修改某个属性时, 直接将该属性对象替换为一个新的值对象即可
					2. "实体"解释
					1. 唯一性: Compilation 由 compilationId成员属性全局唯一地标识了它的身份
					2. 生命周期长, 一个 Compilation 对象会存活在持久化层, 具有最长的生命周期
					3. Compilation 对象是可变的, 体现在其可变成员属性上
				</aside>
				<div class="fragment">
					<pre><code class="kotlin" data-trim data-noescape data-line-numbers>
						class Compilation private constructor(
								val compilationID: CompilationID,
								val author: Author,
								private var title: Title,
								private var description: Description?,
								private var cover: String?,
								private var status: CompilationStatus,
								private var createTime: Long
						) : SmartEntity&lt;Compilation>() {
						
							fun title() = title
						
							fun updateTitle(newTitle: Title) {
								title = newTitle
								refreshTouchTime()
							}
						
							/* 
							......... some other detail
							*/
						}
						</code></pre>
				</div>
			</section>

			<section>
				<h4>创建纯洁的领域对象</h4>
				<ul>
					<li>忘记 DB, <span class="ustrong">领域优先</li>
				</ul>
				<aside class="notes">
					例子中是一个典型的 POJO, 或者说 DTO (data transfer object), 而且拥有与 schema 一一对应的字段
				</aside>
				<div class="r-stack">
					<div class="fragment current-visible fade-out">
						<img src="./img/first_line.jpeg" />
					</div>
					<table class="fragment fade-up">
						<tr>
							<th>NO</th>
							<th>YES</th>
						</tr>
						<tr>
							<td>
								<img src='./img/db-orient.jpg' />
							</td>

							<td>
								<img src="./img/domain-orient.jpg">
							</td>
						</tr>
					</table>
				</div>
			</section>
			<section>
				<h4>创建纯洁的领域对象</h4>
				<ul>
					<li>对象对应于<span class="term">上下文</span>中的一个清晰概念</li>
				</ul>
				<aside class="notes">
					对于发布系统上下文
				</aside>
				<table class="fragment fade-in-down">
					<tr>
						<th>NO</th>
						<th>YES</th>
					</tr>
					<tr>
						<td>
							<img src='./img/notclear.jpg' />
						</td>
						<td>
							<img src="./img/clear.jpg">
						</td>
					</tr>
				</table>
			</section>

			<section>
				<h4>创建纯洁的领域对象</h4>
				<ul>
					<li>对象只有单一的<span class="ustrong">职责</span>(SRP)</li>
				</ul>
				<table class="fragment fade-in">
					<tr>
						<th>NO</th>
						<th>YES</th>
					</tr>
					<tr>
						<td>
							<img src="./img/non-srp.jpg">
						</td>
						<td>
							<img src="./img/srp.jpg">
						</td>
					</tr>
				</table>
			</section>
			<section>
				<h4>创建纯洁的领域对象</h4>
				<ul>
					<li>对象<span class="ustrong">不知道</span>其职责以外的任何知识</li>
				</ul>
				<table class="fragment fade-in">
					<tr>
						<th>NO</th>
						<th>YES</th>
					</tr>
					<tr>
						<td>
							<img src="./img/corrupted.jpg" />
						</td>
						<td>
							<img src="./img/pure.jpg" />
						</td>
					</tr>
				</table>
			</section>
			<section>
				<h3>conclusion 2 </h3>
				<ul>
					<li>用领域模型体现<span class="ustrong">业务逻辑</span></li>
					<li>创建<span class="ustrong">纯洁</span>的领域对象</li>
				</ul>
				<aside class="notes" data-markdown data-template>

				</aside>
			</section>

			<section>
				<h3>4. 围绕领域构建服务</h3>
				<ol>
					<li><span class="term">领域模型</span>是整个服务的核心部分</li>
					<li><span class="term">"应用(服务)"</span>是操作领域模型的唯一入口</li>
					<li><span class="ustrong">持久化</span>及IO交给<span class="term">基础设施</span>来实现</li>
				</ol>
			</section>

			<section HOWTO-model data-markdown>
				## DDD 案例研究
				### 3. 创建领域模型
				#### 忘记 DB, 聚焦业务
				1. 不要先设计数据表
				1. 持久化模式由领域模型推导而来
			</section>

			<section>
				<h3>架构一览</h3>
				<aside class="notes" data-template data-markdown>
					不展开讲, 点到为止

					### 组件的介绍
					0. 适配器的作用是保持"应用"为唯一的操作接口
					1. "应用"是整个服务对领域对象操作的唯一入口
					2. "应用"调度"领域服务"和基础设施
					3. 基础设施包含了所有的 IO 操作以及和外部系统(相对于限界上下文)的交互

					TODO 依赖关系图

					### 该架构的好处
					1. 核心部分(领域模型)和实现解耦, 易于测试, 实现容易变化; 相比面条代码正确性更高
					2. 收束领域对象的操作行为到一个地方
					3. (对于开发人员)更清楚地看待业务

					### 架构的形成
					1. 得到了有用的领域模型
					2. 根据模型设计应用服务的接口(契约, 函数签名)
					3. 根据模型推导持久化的 schema
					4. 推导其它的组件实现

					### 注意
					1. 保持领域的纯洁(避免领域污染), 使用防腐层(比如使用适配器/表面模式);
					1. 保持领域对象的纯洁
					2. 领域完整且自治
					2. (尽力)将 IO 推到系统边界
					1. 保持了领域对象的纯洁
					2. 解耦了业务逻辑和实现,利于重构和变更

				</aside>
				<p><img style="height:600px" src="./img/architecture.svg" /></p>
			</section>
			<section>
				<h3>conclusion 3</h3>
				<ul>
					<li>架构/基础设施应该与<span class="term">领域模型</span>解耦</li>
					<li>使用 CQRS 模式</li>
				</ul>
				<aside class="notes" data-template data-markdown>
					CQRS = 命令查询责任分离
					1. 写模型易于抽象成领域模型, 读模型则不是
					2. 分离后每个服务专注于单独的一个职责(读/写)
					3. 读写的同步问题
				</aside>
			</section>
			<!-- </section> -->

			<!--4 总结-->
			<!-- <section CONCLUSION> -->
			<section>

				<h2>To sum it up</h2>
				<aside class="notes">
					回顾观点
				</aside>
			</section>
			<section>
				<h4>DDD 是什么?</h4>
				<p>以业务为中心的软件设计和实施方法论</p>
			</section>

			<section>
				<h4>为什么要学习 DDD ?</h4>
				<ul>
					<li>产研实践损害了业务完整性</li>
					<li>DDD 框架围绕业务开展活动</li>
				</ul>
			</section>

			<section>
				<h4>DDD 案例研究</h4>
				<ol>
					<li>梳理业务逻辑</li>
					<li>建立并输出业务共识</li>
					<li>设计领域模型</li>
					<li>推导并实现服务组件</li>
				</ol>
			</section>
			<!-- </section> -->


			<!-- <section MORE> -->
			<section>
				<h2>More</h2>
			</section>
			<section>
				<h3>Q & A</h3>
			</section>
			<section>
				<h3>References</h3>
				<h4>if you're still interested</h4>
				<p>欢迎阅读 <a
						href="https://wiki.quickcan.com/pages/viewpage.action?pageId=175243524#DDD(领域驱动设计)实践-review_log">DDD
						实战记录</a></p>
				<p>以及参考<a
						href="https://git.quickcan.com/social/social-feed-service/-/tree/master/src/main/kotlin/com/kk/social/experimental/ddd/compilation"
						target="_blank">社区合集实现</a>
				</p>
			</section>
			<!-- </section> -->
		</div>
	</div>

	<script src="dist/reveal.js"></script>
	<script src="plugin/notes/notes.js"></script>
	<script src="plugin/markdown/markdown.js"></script>
	<script src="plugin/highlight/highlight.js"></script>
	<script>
		// More info about initialization & config:
		// - https://revealjs.com/initialization/
		// - https://revealjs.com/config/
		Reveal.initialize({
			hash: true,

			// Learn about plugins: https://revealjs.com/plugins/
			plugins: [RevealMarkdown, RevealHighlight, RevealNotes]
		});
		Reveal.configure({ pdfSeparateFragments: false });
	</script>
	<style type="text/css">
		.reveal section pre code {
			font-size: 0.7em !important;
		}

		.reveal section .ustrong {
			color: #CC3300;
			font-style: bold !important;
			font-weight: 500px !important;
		}

		.reveal section.dialogue p {
			font-size: 0.6em !important;
			text-align: left;
			padding-left: 2em;
		}

		.reveal section .term {
			font-style: normal !important;
			color: #0099ff !important;
			border-bottom: 1px solid;
		}

		@media print {
			.slide-background {
				background-color: #222 !important;
				-webkit-print-color-adjust: exact;
			}
		}

		.reveal section img {
			max-height: 600px;
			margin-top: 0;
		}

		.reveal section .two-in-row {
			height: 500px;
			text-align: center;
			font-size: 0;
			# width: 30vw;
			# margin: 0 auto;
		}

		.reveal section .two-in-row img {
			display: inline-block;
			# width: 50%;
			height: 90%;
			border: 1px white solid
		}


	</style>
</body>

</html>