<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>Meaningful DDD</title>

		<link rel="stylesheet" href="dist/reset.css">
		<link rel="stylesheet" href="dist/reveal.css">
		<link rel="stylesheet" href="dist/theme/blood.css" id="theme">

		<!-- Theme used for syntax highlighted code -->
		<link rel="stylesheet" href="plugin/highlight/monokai.css" id="highlight-theme">
	</head>
	<body>
		<div class="reveal">
			<div class="slides">
				<section data-markdown>
				<textarea data-template>
				## When we are coding...
				</textarea>
				</section>
				<section>
					<h2>We expect</h2>
					<p class="fragment">恰当的设计</p>
					<p class="fragment">优雅的实现</p>
					<p class="fragment">最佳实践</p>

					<aside class="notes">
					TODO some examples and axioms or idioms?
					</aside>
				</section>			

				<section>
					<h2>Nonetheless...</h2>
					<h2 class="fragment">We got</h2>
				</section>		

				<section>
					<section>
						<h3>"过程式"</h3>
						<p class="fragment">which is often toooooo damn long</p>
					</section>
					<section>
						<h3>Stiff "MVC"</h3>
						<p class="fragment">too simple, sometimes naive</p>
					</section>
										<section>
					<p>A RestController</p>
					<pre><code class="kotlin" data-trim data-noescape>
					class RecommendUser{
						override fun getRecommendUsersV3(uid: Int, deviceId: String, limit: Int): List<RecommendUser> {
							return recommendUserService.getRecommendUsers(uid, deviceId, limit)
						}
					}
					</code></pre>
					</section>

<section>
<pre><code class="kotlin" data-trim data-noescape>
fun getAppHomeRecommendUsers(uid: Int, deviceId: String): AppHomeRecommendUsers {
    val defaultRes = AppHomeRecommendUsers(-1, "", emptyList())
    return runBlocking(LocalPool) {
        try {
            if (uid < 0 && deviceId.isBlank()) return@runBlocking defaultRes
            //获取首页位置
            val position: Int = getHomePosition()
            if (position == 0) return@runBlocking defaultRes

            val fetched = async(RedisPool) { getUserFetched(uid, deviceId) }
            val screened = async(RedisPool) { 
				if (uid > 0) getScreenedRecommendUsers(uid) else emptySet() 
			}
            val followed = async(RemotePool) {
				 if (uid > 0) userClient.getAllFollowings(uid) + uid 
				 else emptyList<Int>() 
			}
            //首页默认取5个
            var given = getAppHomeConfiguredUsers(fetched.await() + 
				screened.await() + followed.await(), 5)
            //循环展示..
            if (given.size < 5) {
                val not = screened.await() + followed.await()
                given += getAppHomeConfiguredUsers(
					given.map { it.uid } + not,
				 	5 - given.size
				)
                threadPool.safeExecute {
                    clearUserSeen(uid, deviceId)
                }
            }

            //少于2个不下发
            if (given.size < 2) return@runBlocking defaultRes

            //获取conf
            val confs = given.map { it.uid to RecommendUser(it) }.toMap()
            val uids = given.map { it.uid }

            //获取post
            val posts = getTopPostsOf(uids, 5)


            val title = "他们都在快看世界"
            val users = uids.mapNotNull { uid ->
                val userPosts = posts.get(uid)
                if (confs[uid] == null || 
				userPosts == null || 
				userPosts.isEmpty()) return@mapNotNull null
                //posts只取一个
                RecommendUserWithPosts(confs[uid] ?: return@mapNotNull null, userPosts.subList(0, 1))
            }

            if (users.isEmpty()) return@runBlocking defaultRes

            //记录看过的
            val user = if (uid > 0) uid.toString() else deviceId
            seenUserProcessor.onNext(user to users.map { it.user.uid })
            //置底
            AppHomeRecommendUsers(if (position != 999999) position - 1 else 999999, title, users)
        } catch (e: Throwable) {
            logger.error("getAppHomeRecommendUsers($uid, $deviceId) caught exception", e)
            defaultRes
        }
    }
}
</code></pre>
</section>
				</section>

				<section data-markdown>
					<textarea data-template>
					<h2>What's wrong?</h2>
					<p class="fragment">"没有设计"</p>
					</textarea>

					<aside class="notes">
						这是一个恰如其分的评价, 正如字面上所述, 我看到的大多数代码都"没有设计";

						Xy. Ma 曾经说过 "有设计比没有设计要强"; 在我所见的代码范围内, 这句话是很适用的.

						先看看我们常见的"设计"思路: 嗯, 这个功能的**数据**需要这样一张表存储, 先写好 dao 层; 再把接口定义好, 剩下的业务逻辑, 嗯, 全部放在 service 层...

						我的设计思路是这样: 先给出接口协议, 然后再实现; 但是我也仍然逃不开先设计表的窠臼; 而且自顶向下设计时, **顶层抽象**做的总是不够好. 比如:

						TODO 举例说明顶层抽象的困难
					</aside>
				</section>

				<section data-markdown>
					<textarea data-template>
					## DDD comes to rescue?
					</textarea>

					<aside class="notes">
					在我的小实践之后, 我要给出我的结论: DDD 很有用;

					DDD 提供了一整套**方法论**, 能够指导我们**设计出较高质量的代码结构**; 

					"抽象"这件事长期困扰我, 现在我有了一套指导原则和行动手册;

					</aside>
				</section>

				<section>
					<section>
						<h3>What's "DDD", anyway?</h3>
						<p class="fragment">Domain Driven Design</p>
						<p class="fragment">"领域驱动设计"</p>
						<p class="fragment">它是一套行动的<span class="ustrong">方法论</span></p>
					</section>
					<section>
						<h4>Why DDD?</h4>
						<ul>						
						<li class="fragment">以<b>业务</b>为核心, 围绕业务开展活动</p>
						<li class="fragment">建立全员一致的业务理解</p>
						<li class="fragment">更好的团队投入与参与(产品, 运营, 开发者, etc)</p>
						<li class="fragment">更好的发掘/梳理业务价值, 聚焦高价值的业务</p>
						<li class="fragment">代码即业务逻辑</p>
						<li class="fragment">代码更加易于维护,扩展;(可能)更高的代码质量</p>
						</ul>
					</section>
					<section>
						<h3>Kick Off Steps<sup title="参考自">*</sup></h3>
						<ul>
							<li></li>
							<li></li>
							<li></li>
						</ul>
					</section>
				</section>
				<section>
					<h3>References</h3>
					<p>
						<a href="https://git.quickcan.com/social/social-feed-service/" target="_blank">社区的帖子合集需求实现</a>
					</p>
				</section>

				<section><h3>Q & A</h3></section>
			</div>
		</div>

		<script src="dist/reveal.js"></script>
		<script src="plugin/notes/notes.js"></script>
		<script src="plugin/markdown/markdown.js"></script>
		<script src="plugin/highlight/highlight.js"></script>
		<script>
			// More info about initialization & config:
			// - https://revealjs.com/initialization/
			// - https://revealjs.com/config/
			Reveal.initialize({
				hash: true,

				// Learn about plugins: https://revealjs.com/plugins/
				plugins: [ RevealMarkdown, RevealHighlight, RevealNotes ]
			});

		</script>
		<style type="text/css">
			.reveal section pre code {
				font-size: 0.7em !important;
			}
			.reveal section span .ustrong {
				color: #CC3300;
				font-style:	bold;
			}
		</style>
	</body>
</html>
